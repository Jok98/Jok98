\documentclass[a4paper, 12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{todonotes}

\pagestyle{fancy}

\geometry{margin=1in}

% Java code setup
\lstset{
    language=Java, % Language specification
    basicstyle=\ttfamily\small, % Code font size and type
    keywordstyle=\color{blue}\bfseries, % Keywords color
    stringstyle=\color{teal}, % Strings color
    commentstyle=\color{olive}, % Comments color
    numbers=left, % Line numbers
    numberstyle=\tiny\color{gray}, % Line numbers style
    stepnumber=1, % The step between two line numbers
    numbersep=5pt, % How far the line numbers are from the code
    backgroundcolor=\color{lightgray!10}, % Background color for the code block
    showspaces=false, % Show spaces in the code
    showstringspaces=false, % Don't show spaces in strings
    tabsize=4, % Tab size
    breaklines=true, % Line breaking
    breakatwhitespace=true, % Break lines only at whitespace
    frame=single, % Adds a frame around the code
    captionpos=b, % Caption position: 't' for top and 'b' for bottom
}
%\begin{lstlisting}[language=yaml]
\lstdefinelanguage{yaml}{
    keywords={true, false, null, yes, no},
    keywordstyle=\color{blue}\bfseries,
    basicstyle=\ttfamily,
    sensitive=false,
    comment=[l]{\#},
    commentstyle=\color{gray}\ttfamily,
    morestring=[b]',
    morestring=[b]",
    stringstyle=\color{orange},
    literate =    {---}{{\processthree}}3
        {>}{{\textcolor{red}{>}}}1
        {|}{{\textcolor{red}{|}}}1
        {*}{{\textcolor{red}{*}}}1
        {:}{{\textcolor{red}{:}}}1,
}

% Header configuration
\fancyhead[L]{\href{https://github.com/Jok98}{GitHub}}
\fancyhead[R]{\href{https://www.linkedin.com/in/matteo-moi/}{LinkedIn}}

\begin{document}

    \title{SpringBoot}
    \author{Matteo Moi}
    \date{}
    \maketitle

    \tableofcontents
    \newpage


    \section{Spring/SpringBoot fundamental concepts}

    \subsection{Inversion of Control (IoC)}
    \textit{\textbf{Definition}}: IoC is a design principle where the control flow of a program is inverted. Instead of the application code controlling the flow, the framework takes control of the flow and instantiates and manages the lifecycle of objects.

    \subsection{Dependency Injection}
    \textit{\textbf{Definition}}: It is a technique where an object receives its dependencies from an external source(in this case Spring Framework) rather than creating them internally.

    \subsubsection{Types of Injection in Spring}
    \begin{itemize}
        \item \textbf{Constructor Injection}
        \begin{lstlisting}
@Component
class Client {
    private final Service service;

    // Constructor injection
    @Autowired
    public Client(Service service) {
        this.service = service;
    }
        \end{lstlisting}
        \item \textbf{Setter Injection}
        \begin{lstlisting}
@Component
class Client {
    private Service service;

    // Setter injection
    @Autowired
    public void setService(Service service) {
        this.service = service;
    }
        \end{lstlisting}
        \item \textbf{Field Injection}
        \begin{lstlisting}
@Component
class Client {

    // Field injection
    @Autowired
    private Service service;
        \end{lstlisting}

    \end{itemize}


    \section{SpringBoot Annotation}
    \begin{itemize}
        \item \textbf{@SpringBootApplication}
        \item \textbf{@Component}
        \item \textbf{@Configuration}
    \end{itemize}

    \subsection{@SpringBootApplication}
    \begin{lstlisting}
@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}
    \end{lstlisting}
    This annotation is a shortcut that combines three fundamental annotations in Spring :

    \begin{table}[h]
        \centering
        \begin{tabular}{|c|p{10cm}|}
            \hline
            Annotation               & Description                                                                                                                                                                            \\ \hline
            @Configuration           & Indicates that the class can be used by the Spring IoC container as a source of bean definitions.                                                                                      \\ \hline
            @EnableAutoConfiguration & Enables the auto-configuration, which automatically configures your application based on the dependencies you have added.                                                              \\ \hline
            @ComponentScan           & Instructs Spring to scan the current package and its sub-packages for components, configurations, and services, allowing it to detect and register beans with the application context. \\ \hline
        \end{tabular}
        \label{tab:Annotation}
    \end{table}

    \subsection{@Component}
    It is used to mark a Java class as a "component" so that Spring can automatically detect and manage the class as a bean within its Inversion of Control (IoC) container without explicit configuration.
    \begin{lstlisting}
@Component
public class MyComponent {
    public void performAction() {
        // Business logic here
    }
}
    \end{lstlisting}

    \subsubsection{Specialized Stereotypes}
    \begin{table}[h!]
        \centering
        \begin{tabular}{|c|p{10cm}|}
            \hline
            Annotation      & Description                                                                                 \\ \hline
            @Service        & Indicates that the class holds business logic                                               \\ \hline
            @Repository     & Indicates that the class is a Data Access Object (DAO) and will interact with the database. \\ \hline
            @Controller     & Used in Spring MVC to denote a controller class that handles HTTP requests                  \\ \hline
            @RestController & combines @Controller and @ResponseBody. It is used in RESTful web services                  \\ \hline
        \end{tabular}
        \label{tab:Annotation}
    \end{table}

    \newpage

    \subsection{@Configuration}
    Purpose :
    \begin{itemize}
        \item Define Beans in Java: @Configuration classes are used to define beans using methods annotated with @Bean. This enables type-safe, refactor-friendly configuration
        \item Initialize Application Context: Acts as a source for the Spring container to generate and manage bean definitions at runtime.
    \end{itemize}
    \begin{lstlisting}
@Configuration
public class AppConfig {

    @Bean
    public DataSource dataSource() {
        // Configure and return the necessary JDBC DataSource
    \end{lstlisting}

    \newpage


    \section{Spring Data}

    In Spring Data, an entity represents a database table, and a repository provides an abstraction to perform CRUD operations on the entity. Spring Data JPA automates the creation of the repository based on the interfaces you define.

    \subsection{Entity}
    The class is annotated with @Entity and the fields with annotations like @Id and @GeneratedValue to define the primary key and its auto-generation strategy.

    \subsubsection{JPA}
    \begin{lstlisting}
@Entity
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private String email;

    // Default constructor required by JPA
    public User() {}
    \end{lstlisting}

    \subsubsection{Mongo}
    \begin{lstlisting}
@Document(collection = "users")  // Specifies the MongoDB collection name
public class User {

    @Id
    private String id;  // MongoDB will automatically generate the `_id` field
    private String name;
    private String email;

    // Default constructor required by Spring Data
    public User() {}
    \end{lstlisting}

    \subsection{Repository}
    The repository interface provides methods to interact with the database(CRUD ops) extending JpaRepository (or CrudRepository) gives these functionalities automatically.

    \begin{lstlisting}
@Repository
public interface UserRepository extends JpaRepository<User, Long> {

    // You can define custom query methods here
    User findByEmail(String email);
}
    \end{lstlisting}

    \subsubsection{Reactive Repository}
    B ased on non-blocking I/O this interface do not
    return objects or collections of objects; instead, return Mono and Flux objects which ones are reactive streams that are
    capable of returning either 0...1 or 0...m entities as they become available on the stream. (Supported by Mongo, not supported by JPA)
    \begin{lstlisting}
@Repository
public interface UserRepository extends ReactiveCrudRepository<User, Long> {

    // You can define custom query methods here
    Flux<User> findByEmail(String email);
}
    \end{lstlisting}

    \subsection{Service}
    A service layer is a common way to encapsulate business logic and handle repository interactions.
    \begin{lstlisting}
@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    public List<User> getAllUsers() {
        return userRepository.findAll();
    }

    public User getUserById(Long id) {
        return userRepository.findById(id).orElse(null);
    }
    \end{lstlisting}

    \newpage


    \section{Spring Cloud}

    \subsection{Spring Cloud Stream}

    \textit{\textbf{Definition}}: SCS provides a streaming abstraction over messaging, based on the publish and subscribe integration pattern. SCS comes with built-in support for Apache Kafka and RabbitMQ.

    \subsubsection{Core concepts}

    \begin{itemize}
        \item \textbf{Message}: A data structure that's used to describe data sent to and received from a messaging system.
        \item \textbf{Publisher(Supplier)}: Sends messages to the messaging system
        \item \textbf{Subscriber(Consumer)}: Receives messages from the messaging system
        \item \textbf{Destination}: Used to communicate with the messaging system.
        Publisher use output destinations and Subscriber input destinations.
        Destinations are mapped by specific binders to queues and topics in the underlying messaging system.
        \item \textbf{Binder}: provides the actual integration with a specific messaging system(similar to jdbc with a specific database)
    \end{itemize}

    \subsection{System Messaging Impl}
    \begin{itemize}
        \item \textbf{Publisher}
        \begin{lstlisting}
    @Bean
    public Supplier<String> myPublisher() {
        return()-> new Date().toString();
    }
        \end{lstlisting}
        \item \textbf{Consumer}
        \begin{lstlisting}
    @Bean
    public Consumer<String> mySubscriber() {
        return s -> System.out.println("Message received: "+s );
    }
        \end{lstlisting}
        \item \textbf{Supplier/Consumer}
        \begin{lstlisting}
    @Bean
    public Function<String> myProcessor() {
        return s -> "Message received: "+s;
    }
        \end{lstlisting}

        \item \textbf{Properties}
        \begin{lstlisting}
        # To make Spring aware of these functions
        spring.cloud.function:
            definition: myPublisher; MyProcessor; mySubscriber
        # To tell Spring what destination to use for each function
        spring.cloud.stream.bindings
            myPublisher-out-0:
                destination: myProcessor-in
            myProcessor-in-0:
                destination: myProcessor-in
            myProcessor-out-0:
                destination: myProcessor-out
            myConsumer-in-0:
                destination: myProcessor-out
        \end{lstlisting}
        Result : myPublisher -> myProcessor -> mySubscriber

        On default the supplier is triggered by default every second but if you want to trigger it by an external event like a REST Api is called then:
        \begin{lstlisting}
    @Autowired
    private StreamBridge streamBridge;

    @PostMapping
    void exApi(@RequestBody String body){
    streamBridge.send("myProcessor-in-0", body);

    }
        \end{lstlisting}
    \end{itemize}


    \section{TODO}
    \begin{itemize}
        \item add to Spring data example with Generics
    \end{itemize}

    \section{in progress...}
\end{document}