\documentclass[a4paper, 12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{todonotes}

\pagestyle{fancy}

\geometry{margin=1in}

% Java code setup
\lstset{
    language=Java, % Language specification
    basicstyle=\ttfamily\small, % Code font size and type
    keywordstyle=\color{blue}\bfseries, % Keywords color
    stringstyle=\color{teal}, % Strings color
    commentstyle=\color{olive}, % Comments color
    numbers=left, % Line numbers
    numberstyle=\tiny\color{gray}, % Line numbers style
    stepnumber=1, % The step between two line numbers
    numbersep=5pt, % How far the line numbers are from the code
    backgroundcolor=\color{lightgray!10}, % Background color for the code block
    showspaces=false, % Show spaces in the code
    showstringspaces=false, % Don't show spaces in strings
    tabsize=4, % Tab size
    breaklines=true, % Line breaking
    breakatwhitespace=true, % Break lines only at whitespace
    frame=single, % Adds a frame around the code
    captionpos=b, % Caption position: 't' for top and 'b' for bottom
}
%\begin{lstlisting}[language=yaml]
\lstdefinelanguage{yaml}{
    keywords={true, false, null, yes, no},
    keywordstyle=\color{blue}\bfseries,
    basicstyle=\ttfamily,
    sensitive=false,
    comment=[l]{\#},
    commentstyle=\color{gray}\ttfamily,
    morestring=[b]',
    morestring=[b]",
    stringstyle=\color{orange},
    literate =    {---}{{\processthree}}3
        {>}{{\textcolor{red}{>}}}1
        {|}{{\textcolor{red}{|}}}1
        {*}{{\textcolor{red}{*}}}1
        {:}{{\textcolor{red}{:}}}1,
}

% Header configuration
\fancyhead[L]{\href{https://github.com/Jok98}{GitHub}}
\fancyhead[R]{\href{https://www.linkedin.com/in/matteo-moi/}{LinkedIn}}

\begin{document}

    \title{SpringBoot}
    \author{Matteo Moi}
    \date{}
    \maketitle

    \tableofcontents
    \newpage


    \section{Spring/SpringBoot fundamental concepts}

    \subsection{Inversion of Control (IoC)}
    \textit{\textbf{Definition}}: IoC is a design principle where the control flow of a program is inverted. Instead of the application code controlling the flow, the framework takes control of the flow and instantiates and manages the lifecycle of objects.

    \subsection{Dependency Injection}
    \textit{\textbf{Definition}}: It is a technique where an object receives its dependencies from an external source(in this case Spring Framework) rather than creating them internally.

    \subsubsection{Types of Injection in Spring}
    \begin{itemize}
        \item \textbf{Constructor Injection}
        \begin{lstlisting}
@Component
class Client {
    private final Service service;

    // Constructor injection
    @Autowired
    public Client(Service service) {
        this.service = service;
    }
        \end{lstlisting}
        \item \textbf{Setter Injection}
        \begin{lstlisting}
@Component
class Client {
    private Service service;

    // Setter injection
    @Autowired
    public void setService(Service service) {
        this.service = service;
    }
        \end{lstlisting}
        \item \textbf{Field Injection}
        \begin{lstlisting}
@Component
class Client {

    // Field injection
    @Autowired
    private Service service;
        \end{lstlisting}

    \end{itemize}


    \section{SpringBoot Annotation}
    \begin{itemize}
        \item \textbf{@SpringBootApplication}
        \item \textbf{@Component}
        \item \textbf{@Configuration}
    \end{itemize}

    \subsection{@SpringBootApplication}
    \begin{lstlisting}
@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}
    \end{lstlisting}
    This annotation is a shortcut that combines three fundamental annotations in Spring :

    \begin{table}[h]
        \centering
        \begin{tabular}{|c|p{10cm}|}
            \hline
            Annotation               & Description                                                                                                                                                                            \\ \hline
            @Configuration           & Indicates that the class can be used by the Spring IoC container as a source of bean definitions.                                                                                      \\ \hline
            @EnableAutoConfiguration & Enables the auto-configuration, which automatically configures your application based on the dependencies you have added.                                                              \\ \hline
            @ComponentScan           & Instructs Spring to scan the current package and its sub-packages for components, configurations, and services, allowing it to detect and register beans with the application context. \\ \hline
        \end{tabular}
        \label{tab:Annotation}
    \end{table}

    \subsection{@Component}
    It is used to mark a Java class as a "component" so that Spring can automatically detect and manage the class as a bean within its Inversion of Control (IoC) container without explicit configuration.
    \begin{lstlisting}
@Component
public class MyComponent {
    public void performAction() {
        // Business logic here
    }
}
    \end{lstlisting}

    \subsubsection{Specialized Stereotypes}
    \begin{table}[h!]
        \centering
        \begin{tabular}{|c|p{10cm}|}
            \hline
            Annotation      & Description                                                                                 \\ \hline
            @Service        & Indicates that the class holds business logic                                               \\ \hline
            @Repository     & Indicates that the class is a Data Access Object (DAO) and will interact with the database. \\ \hline
            @Controller     & Used in Spring MVC to denote a controller class that handles HTTP requests                  \\ \hline
            @RestController & combines @Controller and @ResponseBody. It is used in RESTful web services                  \\ \hline
        \end{tabular}
        \label{tab:Annotation}
    \end{table}

    \newpage

    \subsection{@Configuration}
    Purpose :
    \begin{itemize}
        \item Define Beans in Java: @Configuration classes are used to define beans using methods annotated with @Bean. This enables type-safe, refactor-friendly configuration
        \item Initialize Application Context: Acts as a source for the Spring container to generate and manage bean definitions at runtime.
    \end{itemize}
    \begin{lstlisting}
@Configuration
public class AppConfig {

    @Bean
    public DataSource dataSource() {
        // Configure and return the necessary JDBC DataSource
    \end{lstlisting}

    \newpage


    \section{Spring Data}

    In Spring Data, an entity represents a database table, and a repository provides an abstraction to perform CRUD operations on the entity. Spring Data JPA automates the creation of the repository based on the interfaces you define.

    \subsection{Configuration}
    \begin{lstlisting}[language=yaml]
spring.datasource.url= jdbc:mysql//localhost:3306/db_name
spring.datasource.username= username
spring.datasource.password= password
    \end{lstlisting}

    \subsection{Entity}
    The class is annotated with @Entity and the fields with annotations like @Id and @GeneratedValue to define the primary key and its auto-generation strategy.

    \subsubsection{JPA}
    \begin{lstlisting}
@Entity
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private String email;

    // Default constructor required by JPA
    public User() {}
    \end{lstlisting}

    \subsubsection{Mongo}
    \begin{lstlisting}
@Document(collection = "users")  // Specifies the MongoDB collection name
public class User {

    @Id
    private String id;  // MongoDB will automatically generate the `_id` field
    private String name;
    private String email;

    // Default constructor required by Spring Data
    public User() {}
    \end{lstlisting}

    \subsection{Repository}
    The repository interface provides methods to interact with the database(CRUD ops) extending JpaRepository (or CrudRepository) gives these functionalities automatically.

    \begin{lstlisting}
@Repository
public interface UserRepository extends JpaRepository<User, Long> {

    // You can define custom query methods here
    User findByEmail(String email);
}
    \end{lstlisting}

    \subsubsection{Reactive Repository}
    B ased on non-blocking I/O this interface do not
    return objects or collections of objects; instead, return Mono and Flux objects which ones are reactive streams that are
    capable of returning either 0...1 or 0...m entities as they become available on the stream. (Supported by Mongo, not supported by JPA)
    \begin{lstlisting}
@Repository
public interface UserRepository extends ReactiveCrudRepository<User, Long> {

    // You can define custom query methods here
    Flux<User> findByEmail(String email);
}
    \end{lstlisting}

    \subsection{Service}
    A service layer is a common way to encapsulate business logic and handle repository interactions.
    \begin{lstlisting}
@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    public List<User> getAllUsers() {
        return userRepository.findAll();
    }

    public User getUserById(Long id) {
        return userRepository.findById(id).orElse(null);
    }
    \end{lstlisting}
    \newpage


    \section{Spring REST}

    \subsection{Java JSON Data Binding}
    Also know as :
    \begin{itemize}
        \item Mapping
        \item Serialization/Deserialization
        \item Marshalling/Unmarshalling
    \end{itemize}
    Is the process to covert a json to a java pojo and vice versa,Jackson Project handles the data binding (is automatically included in SB Starter Web). It work through attributes and getter/setter method of java pojo.

    \subsection{HTTP Methods and Status Codes}
    \begin{table}[h!]
        \centering
        \begin{tabular}{|c|c|c|c|}
            \hline
            Method & Description                 & Data placement                 & Code \\ \hline
            POST   & create new resources        & request body                   & 201  \\ \hline
            GET    & request data                & URL parameters (query strings) & 200  \\ \hline
            PUT    & update an existing resource & request body                   & 200  \\ \hline
            DELETE & delete a specified resource & URL parameters (query strings) & 204  \\ \hline
        \end{tabular}
        \label{tab:Annotation}
    \end{table}

    \subsection{@RestController}
    \begin{lstlisting}
@RestController
@RequestMapping("/api/books")
public class BookController {
    \end{lstlisting}
    \begin{itemize}
        \item \textbf{@RestController}: Indicates that the class handles REST requests and automatically serializes responses to JSON.
        \item \textbf{@RequestMapping}("/api/books"): Sets the base URI for all endpoints in the controller.
    \end{itemize}

    \subsection{POST}
    \begin{lstlisting}
    // **Create a new book**
    @PostMapping
    public ResponseEntity<Book> createBook(@RequestBody Book book) {
        Book savedBook = bookRepository.save(book);
        return new ResponseEntity<>(savedBook, HttpStatus.CREATED);
    }
    \end{lstlisting}

    \subsection{GET}
    \begin{lstlisting}
    // **Get all books**
    @GetMapping
    public List<Book> getAllBooks() {
        return bookRepository.findAll();
    }
    \end{lstlisting}

    \begin{lstlisting}
    // **Get a book by ID**
    @GetMapping("/{id}")
    public ResponseEntity<Book> getBookById(@PathVariable Long id) {
        Optional<Book> book = bookRepository.findById(id);
        return book.map(value -> ResponseEntity.ok().body(value))
                   .orElseGet(() -> ResponseEntity.notFound().build());
    }
    \end{lstlisting}

    \subsection{PUT}
    \begin{lstlisting}
    // **Update a book**
    @PutMapping("/{id}")
    public ResponseEntity<Book> updateBook(@PathVariable Long id, @RequestBody Book bookDetails) {
        Optional<Book> optionalBook = bookRepository.findById(id);

        if (optionalBook.isPresent()) {
            Book book = optionalBook.get();
            book.setTitle(bookDetails.getTitle());
            book.setAuthor(bookDetails.getAuthor());
            book.setIsbn(bookDetails.getIsbn());

            Book updatedBook = bookRepository.save(book);
            return ResponseEntity.ok(updatedBook);
        } else {
            return ResponseEntity.notFound().build();
        }
    }
    \end{lstlisting}

    \subsection{DELETE}
    \begin{lstlisting}
    // **Delete a book**
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteBook(@PathVariable Long id) {
        Optional<Book> book = bookRepository.findById(id);

        if (book.isPresent()) {
            bookRepository.delete(book.get());
            return ResponseEntity.noContent().build();
        } else {
            return ResponseEntity.notFound().build();
        }
    }
    \end{lstlisting}

    \subsection{Key Annotations}
    \begin{itemize}
        \item \textbf{@PathVariable}: Extracts values from the URI ex.(/api/books/1)
        \item \textbf{@RequestBody}: Binds the HTTP request body to a transfer or domain object.
    \end{itemize}

    \subsection{Exception Handling}

    \subsubsection{Specific Exception Handling}
    \begin{itemize}
        \item Error Class
    \end{itemize}
    \begin{lstlisting}
public class BookErrorResponse{
    private int status;
    private String message;
    private long timeStamp;

    //constructor
    //getter/setter
}
    \end{lstlisting}
    \begin{itemize}
        \item Define exception
    \end{itemize}
    \begin{lstlisting}
public class BookNotFoundException extends RuntimeException {
    public BookNotFoundException(String message){
        super(message)
    }
}
    \end{lstlisting}

    \begin{itemize}
        \item Controller
    \end{itemize}
    \begin{lstlisting}
@ExceptionHandler
public ResponseEntity<BookErrorResponse> handleException(BookNotFoundException exc){
    BookErrorResponse error = new BookErrorResponse();
    error.setStatus(HttpStatus.NOT_FOUND.value());
    error.setMessage(exc.getMessage());
    error.setTimeStamp(System.currentTimeMillis());
    return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);
}
    \end{lstlisting}
    \begin{itemize}
        \item Call the exception
    \end{itemize}
    \begin{lstlisting}
throw new BookNotFoundException("Book not found"+ id);
    \end{lstlisting}

    Error response :
    \begin{lstlisting}[language=yaml]
{
    "status": 404,
    "message": "Book not found 5"
    "timeStamp": 15248923
}
    \end{lstlisting}

    \subsubsection{Global Exception Handling}
    The right method to manage exception :
    \begin{itemize}
        \item Promote reuse
        \item Standardize exception response
        \item Centralizes exception handling
    \end{itemize}

    \textbf{@ControllerAdvice}
    Is similar to an interceptor/filter, can pre-process and post-process.
    Impl : same as specific exception but the exception handling moves from the controller to a new class
    \begin{lstlisting}
    @ControllerAdvice
    public class BookRestExceptionHandler {
        @ExceptionHandler
        public ResponseEntity<BookErrorResponse> handleException(BookNotFoundException exc){
        BookErrorResponse error = new BookErrorResponse();
        error.setStatus(HttpStatus.NOT_FOUND.value());
        error.setMessage(exc.getMessage());
        error.setTimeStamp(System.currentTimeMillis());
        return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);
}
    }
    \end{lstlisting}

    \subsection{Internationalization (i18n)}
    Create a messages.properties file in the same folder of application.properties.
    \begin{lstlisting}[language=yaml]
good.morning.message=Good Morning
    \end{lstlisting}

    x = it | fr | de …
    Create a messages{x}.properties for each language

    \begin{lstlisting}

@Autowired
private MessageSource messageSource;
@GetMapping(path = "/hello-world-internationalized")
public String helloWorldInternationalized() {
        Locale locale = LocaleContextHolder.getLocale();
        return messageSource.getMessage("good.morning.message", null, "Default Message", locale);
}
    \end{lstlisting}


    \newpage


    \section{Spring Cloud}

    \subsection{Spring Cloud Stream}

    \textit{\textbf{Definition}}: SCS provides a streaming abstraction over messaging, based on the publish and subscribe integration pattern. SCS comes with built-in support for Apache Kafka and RabbitMQ.

    \subsubsection{Core concepts}

    \begin{itemize}
        \item \textbf{Message}: A data structure that's used to describe data sent to and received from a messaging system.
        \item \textbf{Publisher(Supplier)}: Sends messages to the messaging system
        \item \textbf{Subscriber(Consumer)}: Receives messages from the messaging system
        \item \textbf{Destination}: Used to communicate with the messaging system.
        Publisher use output destinations and Subscriber input destinations.
        Destinations are mapped by specific binders to queues and topics in the underlying messaging system.
        \item \textbf{Binder}: provides the actual integration with a specific messaging system(similar to jdbc with a specific database)
    \end{itemize}

    \subsection{System Messaging Impl}
    \begin{itemize}
        \item \textbf{Publisher}
        \begin{lstlisting}
    @Bean
    public Supplier<String> myPublisher() {
        return()-> new Date().toString();
    }
        \end{lstlisting}
        \item \textbf{Consumer}
        \begin{lstlisting}
    @Bean
    public Consumer<String> mySubscriber() {
        return s -> System.out.println("Message received: "+s );
    }
        \end{lstlisting}
        \item \textbf{Supplier/Consumer}
        \begin{lstlisting}
    @Bean
    public Function<String> myProcessor() {
        return s -> "Message received: "+s;
    }
        \end{lstlisting}

        \item \textbf{Properties}
        \begin{lstlisting}
        # To make Spring aware of these functions
        spring.cloud.function:
            definition: myPublisher; MyProcessor; mySubscriber
        # To tell Spring what destination to use for each function
        spring.cloud.stream.bindings
            myPublisher-out-0:
                destination: myProcessor-in
            myProcessor-in-0:
                destination: myProcessor-in
            myProcessor-out-0:
                destination: myProcessor-out
            myConsumer-in-0:
                destination: myProcessor-out
        \end{lstlisting}
        Result : myPublisher -> myProcessor -> mySubscriber

        On default the supplier is triggered by default every second but if you want to trigger it by an external event like a REST Api is called then:
        \begin{lstlisting}
    @Autowired
    private StreamBridge streamBridge;

    @PostMapping
    void exApi(@RequestBody String body){
    streamBridge.send("myProcessor-in-0", body);

    }
        \end{lstlisting}
    \end{itemize}


    \section{in progress...}
\end{document}