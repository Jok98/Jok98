# Helm

Is used in a `Kubernetes` environment to bundle and configure the microservices for `deployments`.<br>
A package is known as a `chart`.<br>
A `chart` contains `templates`, default values for the templates and optional dependencies. <br>
Each component that needs to be deployed will have its own chart describing how to deploy it.<br>
`Library charts` named `common` are used to reduce the boilerplate definitions from the component charts.<br>
A `library chart` doesn't contain any deployable definitions but only reusable templates.<br>
To deploy all components into different types of environments the concept of `parent charts` and `subcharts` will be
used.<br>
Each environment will be implemented as a parent chart that depends on different sets of subcharts.<br>
`Helm charts` can be published to a `helm chart repository`.<br>

```tree
|-- common
|   |-- Chart.yaml
|   |-- templates
|   `-- values.yaml
|-- components
|   |-- auth-server
|   |-- config-server
|   |-- gateway
|   |-- mongodb
|   |-- mysql
|   |-- product
|   |-- rabbitmq
|   `-- zipkin-server
|-- environments
|   |-- dev-env
|   `-- prod-env
```

- **Chart.yaml** contains general information about the chart and a list of other charts it depends on.
- **templates** a folder that contains that will be used to deploy the chart.
- **values.yaml** contains the default values for the templates.
- **Chart.lock** a file created by Helm to keep track of the versions of the dependencies.
- **charts** a folder that contains the dependencies of the chart.
- **.helmignore** a file that contains the files that should be ignored by Helm.

## Commands

- **create**
- **dependency update**
- **dependency build** rebuilds the dependencies based on the Chart.lock file.
- **template** renders the chart templates locally.
- **install:** installs a chart archive.
- **install --dry-run** simulate a deployment without performing it
- **list** lists all installations in the current namespace.
- **upgrade** updates aan existing installation.
- **uninstall** removes an installation.

## Templates

To parameterize Kubernetes manifest files define a common template that contains placeholders
for where microservice-specific values will be placed in the template, when a manifest is rendered for a specific
microservice.<br>
`kubernetes/helm/common/templates/_deployment.yaml`

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "common.fullname" . }}
spec:
  replicas: {{ .Values.replicaCount }}
  template:
    spec:
      containers:
        - name: {{ .Chart.Name }}
```
It is different from the standard Kubernetes manifest file because it uses `{{ }}` to define placeholders for values.
- `{{ include "common.fullname" . }}` is used to invoke other templates.

The other two constructs are used to insert values using one of the built-in objects in Helm.<br>
The most frequently used parts of the built-in objects are:
- `.Values` Used to refer to values in the chart’s values.yaml
- `Release` Used to provide metadata regarding the current release that is installed
    - `Release.Name` The name of the release
    - `Release.Namespace` The namespace of the release
    - `Release.Service` The service that is used to install the release(helm)
- `Chart` Used to access information from the Chart.yaml file
    - `Chart.Name` The name of the chart
    - `Chart.Version` The version of the chart
- `Files` Containing functions for accessing chart-specific files
    - `Files.Glob` Returns files in a chart based on a glob pattern.<br>
        For example, the pattern "config-repo/*" will return all files found in the folder config-repo
    - `AsConfig` Returns the content of files as a YAML map appropriate for declaring values in a ConfigMap
    - `Files.GetSecret` Used to get the contents of a secret
- `Capabilities` an be used to find information regarding the capabilities of the Kubernetes cluster that the installation is performed on.<br>
    For example, a template can use information in this object to adopt a manifest based on what API versions the actual Kubernetes cluster supports.

The single dot `.` is used to refer to the current scope.<br>
The dollar sign `$` is used to refer to the root scope.<br>
Helm templates support the declaration of variables to reference other objects
```yaml
$name := .Release.Name
```

### Common library template
This chart contains reusable templates called `named templates` as they can be invoked in other charts by name.<br>
The structure and content of the chart are based on the output from a helm `create` command.<br>
File `_helpers.tpl` is an autogenerated file that contains functions that defne best practices for naming conventions, for example :
- `common.name` based on the chart name.
- `common.fullname` based on the chart name and the release name.
- `common.chart` based on the chart name and version.
`_.` is used to prevent Helm from trying to create manifests using that specific chart.<br>

### ConfigMap template
Is designed to create ConfigMaps from files in the folder config-repo.<br>
A `ConfigMap` will contain all non-sensitive configuration required by a specific `Deployment`.<br>
The `ConfigMap` will be mounted as a volume in the `Pod` that runs the `Deployment`.<br>
The `Pod` will read the configuration from the `ConfigMap` as files in its local filesystem.<br>
Ex. `_configmap_from_file.yaml`
```yaml
{{- define "common.configmap_from_file" -}}
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "common.fullname" . }}
  labels:
    app.kubernetes.io/name: {{ include "common.name" . }}
    helm.sh/chart: {{ include "common.chart" . }}
    app.kubernetes.io/managed-by: {{ .Release.Service }}
data:
  {{ (.Files.Glob "config-repo/*").AsConfig | indent 2 }}
{{- end -}}
```
explaination:
- `{{- define "common.configmap_from_file" -}}` is used to declare the name of the reusable template.
- `{{ include "common.fullname" . }}` it set the name of the ConfigMap through the file _helpers.tpl.
- `{{ include "common.name" . }}` mark that this Service has been created using Helm.
- `{{ .Release.Service }}` it always returns the value Helm.
- `{{ (.Files.Glob "config-repo/*").AsConfig | indent 2 }}` it reads all files in the folder config-repo and converts them to a YAML map with the right indentation(2 spaces).
- `{{- end -}}` is used to close the template.
Ex. 
```shell
cd /kubernetes/helm/components/config-server
helm dependency update .
helm template . -s templates/configmap_from_file.yaml
```
output:
```yaml
# Source: config-server/templates/configmap_from_file.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: config-server
  labels:
    app.kubernetes.io/name: config-server
    helm.sh/chart: config-server-1.0.0
    app.kubernetes.io/managed-by: Helm
data:
  application.yml: |-
    app:
      auth-server: localhost
    ...
  auth-server.yml: |-
    server.port: 9999
    ...
```

### Secret template 
Is designed to create Secrets defined by values like credentials provided by the environments(ex. dev-env)<br>
The Secrets will be mapped as environment variables in the Pods<br>
The template is designed to create multiple Secret manifests using the range function in Helm.<br>
Ex. _secret.yaml
```yaml
{{- define "common.secrets" -}}
{{- range $secretName, $secretMap := .Values.secrets }}
apiVersion: v1
kind: Secret
metadata:
  name: {{ $secretName }}
  labels:
    app.kubernetes.io/name: {{ $secretName }}
    helm.sh/chart: {{ include "common.chart" $ }}
    app.kubernetes.io/managed-by: {{ $.Release.Service }}
type: Opaque
data:
{{- range $key, $val := $secretMap }}
  {{ $key }}: {{ $val | b64enc }}
{{- end }}
---
{{- end -}}
{{- end -}}
```
- `{{- define "common.secrets" -}}` declaration of the template.
- `{{- range $secretName, $secretMap := .Values.secrets }}` it iterates over the secrets defined in the `values.yaml` file.
- The function assumes that the field `.Values.secrets` contains a map of Secret names and a map of the Secret’s key/value pairs.
- Since the range function changes the current scope, we can no longer use the dot notation to pass the root context to the `common.chart` template.<br> Instead, the variable `$` has to be used.
- In the data section of the manifest, a second range function is applied a second time to traverse the current Secret’s key/value pairs.<br> 
Each key/value pair is assigned by the range function to the variables `$key` and `$val`.
- The Secret’s key/value pairs are defined as a map entry in the data section.<br>
The value in the `$val` variable is piped to the b64enc function to get it properly Base64-encoded as required by a `Secret manifest`.
- The `---` is used to separate the rendered `Secret manifests` from each other so that they are processed as separate YAML documents.


A declaration of the Secrets field in one of the environment’s values.yaml files will look like this:
```yaml
secrets:
  a-secret:
    key-1: secret-value-1
    key-2: secret-value-2
  another-secret:
    key-3: secret-value-3
```
This definition will render two Secrets, named a-secret and another-secret.<br> 
The range function assigns the current Secret name and its map to the variables `$secretName` and `$secretMap`.

to see the output:
```shell
for f in components/*; do helm dependency update $f; done
helm dependency update environments/dev-env
helm template environments/dev-env -s templates/secrets.yaml
```

### Service template

The Service template introduces support for overriding default values from the `common chart`, with values specific to the charts that use the common chart.<br>
Usually the common chart provides default values for the service type and what port will it be exposed on, but you can override these values through the `values.yaml` file of the chart of the specific microservice.<br>
Ex. _service.yaml
```yaml
{{- define "common.service" -}}
{{- $common := dict "Values" .Values.common -}}
{{- $noCommon := omit .Values "common" -}}
{{- $overrides := dict "Values" $noCommon -}}
{{- $noValues := omit . "Values" -}}
{{- with merge $noValues $overrides $common -}}
```
- values from the microservice values.yaml file will be available in the `.Values object`.
- the common chart’s values will be available under the field `.Values.common`.
- `{{- $common := dict "Values" .Values.common -}}` creates a new dictionary with the common chart’s values available under the key `.Values.common`.
- `{{- $noCommon := omit .Values "common" -}}` creates a new dictionary with all values from the microservice and without the common chart’s values.
- `{{- $overrides := dict "Values" $noCommon -}}` will refer to the `$noCommon` dictionary.
- `{{- $noValues := omit . "Values" -}}` will hold all other built-in objects, except for the Values object.
- `{{- with merge $noValues $overrides $common -}}` will merge the three dictionaries into one (`$noValues`, `$overrides`, `$common`).
- values found in the `$overrides` dictionary will take precedence over values in the `$common` dictionary, thereby overriding its values.

Ex. common chart’s values
```yaml
Service:
  type: ClusterIP
  ports:
    - port: 80
      targetPort: http
      protocol: TCP
      name: http
```
The gateway service needs to be a nodeport and use other port settings in order to do so :
override the above default values with chart’s values.yaml file
```yaml
service:
  type: NodePort
  ports:
    - port: 443
      targetPort: 8443
      nodePort: 30443
```

Ex. service template
```yaml
apiVersion: v1
kind: Service
metadata:
  name: {{ include "common.fullname" . }}
  labels:
    app.kubernetes.io/name: {{ include "common.name" . }}
    helm.sh/chart: {{ include "common.chart" . }}
    app.kubernetes.io/managed-by: {{ .Release.Service }}
spec:
  type: {{ .Values.service.type }}
  ports:
    {{ toYaml .Values.service.ports | indent 4 }}
  selector:
    app.kubernetes.io/name: {{ include "common.name" . }}
{{- end -}}
{{- end -}}
```

- `type` `{{ .Values.service.type }}` set the type of the service.
- `ports` `{{ toYaml .Values.service.ports | indent 4 }}` set the ports of the service.
- `selector` `{{ include "common.name" . }}` this is used to select the Pods that the service will route traffic to.

to see the standard output:
```shell
helm dependency update components/product
helm template components/product -s templates/service.yaml
```
to see the output with the override values:
```shell
helm dependency update components/gateway
helm template components/gateway -s templates/service.yaml
```















